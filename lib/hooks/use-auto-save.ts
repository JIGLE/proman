"use client";\n\nimport * as React from \"react\";\nimport { debounce } from \"lodash\";\n\n// Auto-save hook for form data\nexport interface UseAutoSaveOptions {\n  key: string;\n  delay?: number;\n  enabled?: boolean;\n  onSave?: (data: any) => Promise<void>;\n  onRestore?: (data: any) => void;\n  excludeFields?: string[];\n}\n\nexport function useAutoSave<T extends Record<string, any>>(\n  data: T,\n  options: UseAutoSaveOptions\n) {\n  const {\n    key,\n    delay = 2000,\n    enabled = true,\n    onSave,\n    onRestore,\n    excludeFields = []\n  } = options;\n\n  const [isSaving, setIsSaving] = React.useState(false);\n  const [lastSaved, setLastSaved] = React.useState<Date | null>(null);\n  const [hasUnsavedChanges, setHasUnsavedChanges] = React.useState(false);\n  const previousDataRef = React.useRef<T>(data);\n\n  // Filter out excluded fields\n  const getFilteredData = React.useCallback((data: T) => {\n    if (excludeFields.length === 0) return data;\n    \n    const filtered = { ...data };\n    excludeFields.forEach(field => {\n      delete filtered[field];\n    });\n    return filtered;\n  }, [excludeFields]);\n\n  // Save to localStorage\n  const saveToLocalStorage = React.useCallback((data: T) => {\n    try {\n      const filteredData = getFilteredData(data);\n      localStorage.setItem(`autosave_${key}`, JSON.stringify({\n        data: filteredData,\n        timestamp: new Date().toISOString()\n      }));\n      setLastSaved(new Date());\n      setHasUnsavedChanges(false);\n    } catch (error) {\n      console.error('Failed to save to localStorage:', error);\n    }\n  }, [key, getFilteredData]);\n\n  // Restore from localStorage\n  const restoreFromLocalStorage = React.useCallback(() => {\n    try {\n      const saved = localStorage.getItem(`autosave_${key}`);\n      if (saved) {\n        const { data: savedData, timestamp } = JSON.parse(saved);\n        setLastSaved(new Date(timestamp));\n        onRestore?.(savedData);\n        return savedData;\n      }\n    } catch (error) {\n      console.error('Failed to restore from localStorage:', error);\n    }\n    return null;\n  }, [key, onRestore]);\n\n  // Auto-save function with debounce\n  const debouncedSave = React.useMemo(\n    () => debounce(async (data: T) => {\n      if (!enabled) return;\n      \n      setIsSaving(true);\n      \n      try {\n        // Save to localStorage\n        saveToLocalStorage(data);\n        \n        // Call custom save function if provided\n        if (onSave) {\n          await onSave(getFilteredData(data));\n        }\n      } catch (error) {\n        console.error('Auto-save failed:', error);\n      } finally {\n        setIsSaving(false);\n      }\n    }, delay),\n    [enabled, delay, onSave, saveToLocalStorage, getFilteredData]\n  );\n\n  // Track data changes\n  React.useEffect(() => {\n    const currentData = getFilteredData(data);\n    const previousData = getFilteredData(previousDataRef.current);\n    \n    // Check if data has actually changed\n    if (JSON.stringify(currentData) !== JSON.stringify(previousData)) {\n      setHasUnsavedChanges(true);\n      debouncedSave(data);\n      previousDataRef.current = data;\n    }\n  }, [data, debouncedSave, getFilteredData]);\n\n  // Cleanup on unmount\n  React.useEffect(() => {\n    return () => {\n      debouncedSave.cancel();\n    };\n  }, [debouncedSave]);\n\n  // Clear saved data\n  const clearSaved = React.useCallback(() => {\n    localStorage.removeItem(`autosave_${key}`);\n    setLastSaved(null);\n    setHasUnsavedChanges(false);\n  }, [key]);\n\n  // Force save\n  const forceSave = React.useCallback(async () => {\n    debouncedSave.cancel();\n    await debouncedSave(data);\n  }, [data, debouncedSave]);\n\n  // Check if there's saved data available\n  const hasSavedData = React.useCallback(() => {\n    return localStorage.getItem(`autosave_${key}`) !== null;\n  }, [key]);\n\n  return {\n    isSaving,\n    lastSaved,\n    hasUnsavedChanges,\n    restoreFromLocalStorage,\n    clearSaved,\n    forceSave,\n    hasSavedData\n  };\n}\n\n// Form persistence hook for maintaining form state\nexport interface UseFormPersistenceOptions {\n  key: string;\n  enabled?: boolean;\n  fields?: string[];\n  ttl?: number; // Time to live in milliseconds\n}\n\nexport function useFormPersistence<T extends Record<string, any>>(\n  formData: T,\n  setFormData: (data: T | ((prev: T) => T)) => void,\n  options: UseFormPersistenceOptions\n) {\n  const { key, enabled = true, fields, ttl } = options;\n\n  // Save form data to localStorage\n  const saveFormData = React.useCallback(() => {\n    if (!enabled) return;\n    \n    try {\n      const dataToSave = fields \n        ? Object.fromEntries(\n            Object.entries(formData).filter(([k]) => fields.includes(k))\n          )\n        : formData;\n      \n      const persistData = {\n        data: dataToSave,\n        timestamp: Date.now()\n      };\n      \n      localStorage.setItem(`form_${key}`, JSON.stringify(persistData));\n    } catch (error) {\n      console.error('Failed to save form data:', error);\n    }\n  }, [enabled, formData, fields, key]);\n\n  // Load form data from localStorage\n  const loadFormData = React.useCallback(() => {\n    if (!enabled) return null;\n    \n    try {\n      const saved = localStorage.getItem(`form_${key}`);\n      if (!saved) return null;\n      \n      const { data, timestamp } = JSON.parse(saved);\n      \n      // Check if data has expired\n      if (ttl && Date.now() - timestamp > ttl) {\n        localStorage.removeItem(`form_${key}`);\n        return null;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error('Failed to load form data:', error);\n      return null;\n    }\n  }, [enabled, key, ttl]);\n\n  // Clear persisted form data\n  const clearFormData = React.useCallback(() => {\n    localStorage.removeItem(`form_${key}`);\n  }, [key]);\n\n  // Check if there's persisted data\n  const hasPersistedData = React.useCallback(() => {\n    return loadFormData() !== null;\n  }, [loadFormData]);\n\n  // Restore form data\n  const restoreFormData = React.useCallback(() => {\n    const savedData = loadFormData();\n    if (savedData) {\n      setFormData(prevData => ({ ...prevData, ...savedData }));\n      return true;\n    }\n    return false;\n  }, [loadFormData, setFormData]);\n\n  // Auto-save on form data changes\n  React.useEffect(() => {\n    const timeoutId = setTimeout(() => {\n      saveFormData();\n    }, 1000); // Debounce saves\n\n    return () => clearTimeout(timeoutId);\n  }, [formData, saveFormData]);\n\n  return {\n    saveFormData,\n    loadFormData,\n    clearFormData,\n    hasPersistedData,\n    restoreFormData\n  };\n}\n\n// Auto-save status component\nexport interface AutoSaveStatusProps {\n  isSaving: boolean;\n  lastSaved: Date | null;\n  hasUnsavedChanges: boolean;\n  className?: string;\n}\n\nexport function AutoSaveStatus({\n  isSaving,\n  lastSaved,\n  hasUnsavedChanges,\n  className\n}: AutoSaveStatusProps) {\n  const getStatusText = () => {\n    if (isSaving) return \"Saving...\";\n    if (hasUnsavedChanges) return \"Unsaved changes\";\n    if (lastSaved) {\n      const now = new Date();\n      const diff = now.getTime() - lastSaved.getTime();\n      const minutes = Math.floor(diff / 60000);\n      \n      if (minutes < 1) return \"Saved just now\";\n      if (minutes < 60) return `Saved ${minutes}m ago`;\n      \n      const hours = Math.floor(minutes / 60);\n      if (hours < 24) return `Saved ${hours}h ago`;\n      \n      return `Saved ${lastSaved.toLocaleDateString()}`;\n    }\n    return \"No changes\";\n  };\n\n  const getStatusColor = () => {\n    if (isSaving) return \"text-[var(--color-warning)]\";\n    if (hasUnsavedChanges) return \"text-[var(--color-error)]\";\n    return \"text-[var(--color-success)]\";\n  };\n\n  return (\n    <div className={cn(\n      \"flex items-center gap-2 text-xs\",\n      getStatusColor(),\n      className\n    )}>\n      {isSaving && (\n        <div className=\"animate-spin rounded-full h-3 w-3 border-b-2 border-current\"></div>\n      )}\n      <span>{getStatusText()}</span>\n    </div>\n  );\n}\n\n// Form recovery component\nexport interface FormRecoveryProps {\n  onRestore: () => void;\n  onDiscard: () => void;\n  lastSaved?: Date;\n  className?: string;\n}\n\nexport function FormRecovery({\n  onRestore,\n  onDiscard,\n  lastSaved,\n  className\n}: FormRecoveryProps) {\n  return (\n    <div className={cn(\n      \"p-4 bg-[var(--color-warning)]/10 border border-[var(--color-warning)]/20 rounded-lg\",\n      className\n    )}>\n      <div className=\"space-y-3\">\n        <div>\n          <h3 className=\"text-sm font-semibold text-[var(--color-foreground)]\">\n            Unsaved changes found\n          </h3>\n          <p className=\"text-xs text-[var(--color-muted-foreground)]\">\n            {lastSaved \n              ? `Last saved: ${lastSaved.toLocaleString()}`\n              : \"We found unsaved changes from a previous session.\"\n            }\n          </p>\n        </div>\n        \n        <div className=\"flex items-center gap-2\">\n          <button\n            type=\"button\"\n            onClick={onRestore}\n            className=\"px-3 py-1.5 text-xs font-medium bg-[var(--color-primary)] text-white rounded hover:bg-[var(--color-primary)]/90 transition-colors\"\n          >\n            Restore changes\n          </button>\n          \n          <button\n            type=\"button\"\n            onClick={onDiscard}\n            className=\"px-3 py-1.5 text-xs font-medium text-[var(--color-muted-foreground)] hover:text-[var(--color-foreground)] transition-colors\"\n          >\n            Discard\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Utility function imports\nfunction cn(...classes: (string | undefined | false | null)[]): string {\n  return classes.filter(Boolean).join(' ');\n}