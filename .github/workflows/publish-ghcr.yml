name: Build and publish to GHCR

on:
  push:
    tags: ['v*']
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run as dry run (true/false)'
        required: false
        default: 'false'
      version:
        description: 'Optional version override (e.g., 1.2.3)'
        required: false
        default: ''
  schedule:
    - cron: '0 6 * * 1' # weekly on Monday at 06:00 UTC (DRY_RUN)

permissions:
  contents: write
  packages: write

concurrency:
  group: publish-ghcr-${{ github.ref }}
  cancel-in-progress: true

jobs:
  verify:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set DRY_RUN for scheduled runs
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "schedule" ]; then
            echo "DRY_RUN=true" >> $GITHUB_ENV
            echo "Scheduled run — setting DRY_RUN=true"
          else
            echo "DRY_RUN=${{ github.event.inputs.dry_run || 'false' }}" >> $GITHUB_ENV
          fi
        shell: bash

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install dependencies
        run: npm ci

      - name: Type-check + lint
        run: |
          npm run type-check || (echo "Type-check failed" && false)
          npm run lint || (echo "Lint failed" && false)

  build-and-publish:
    needs: verify
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      RELEASE_MERGE_METHOD: squash
      DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npx prisma generate || true


      - name: Clean build
        run: |
          rm -rf .next
          npm run build

      - name: Verify no native modules in .next
        run: npm run verify:no-native

      - id: set-vars
        run: |
          set -euo pipefail
          # Determine VERSION: prefer tag (strip leading v), allow workflow input override, fallback to package.json
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
            TAG=${TAG#v}
            if [ -n "${{ github.event.inputs.version }}" ]; then
              VERSION="${{ github.event.inputs.version }}"
            else
              VERSION="$TAG"
            fi
          else
            if [ -n "${{ github.event.inputs.version }}" ]; then
              VERSION="${{ github.event.inputs.version }}"
            else
              VERSION=$(node -e 'console.log(require("./package.json").version)')
            fi
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "GIT_COMMIT=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          echo "BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
        shell: bash

      - name: Assert VERSION matches package.json (for tag-triggered runs)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          PKG_VERSION=$(node -e 'console.log(require("./package.json").version)')
          if [ "$PKG_VERSION" != "${{ steps.set-vars.outputs.VERSION }}" ]; then
            echo "ERROR: version mismatch: package.json=${PKG_VERSION} computed=${{ steps.set-vars.outputs.VERSION }}"
            echo "If you intentionally want the tag to differ, re-run with workflow_dispatch and provide 'version' input."
            exit 1
          fi
        shell: bash

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push multi-arch image
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
          tags: |
            ghcr.io/jigle/proman:${{ steps.set-vars.outputs.VERSION }}
            ghcr.io/jigle/proman:latest
            ghcr.io/jigle/proman:${{ github.sha }}
          build-args: |
            BUILD_VERSION=${{ steps.set-vars.outputs.VERSION }}
            GIT_COMMIT=${{ steps.set-vars.outputs.GIT_COMMIT }}
            BUILD_TIME=${{ steps.set-vars.outputs.BUILD_TIME }}

      - name: Image info
        run: |
          echo "Image pushed: ghcr.io/jigle/proman:${{ steps.set-vars.outputs.VERSION }}"

      - name: Prepare release branch and update Chart + README
        env:
          VERSION: ${{ steps.set-vars.outputs.VERSION }}
        run: |
          set -euo pipefail
          echo "Preparing release artifacts for ${VERSION}"
          # Update Chart.appVersion
          sed -i "s/^appVersion: .*$/appVersion: \"${VERSION}\"/" helm/proman/Chart.yaml

          # Create release note and insert under '## Releases' heading in README.md
          DATE=$(date -u +"%Y-%m-%d")
          RELEASE_NOTE="- Date: ${DATE}\n- Version: ${VERSION}\n- Image: ghcr.io/jigle/proman:${VERSION}\n- Notes: automated release"

          awk -v note="$RELEASE_NOTE" 'BEGIN{printed=0} {print} /^## Releases/ && !printed {print ""; print note; printed=1}' README.md > README.md.tmp && mv README.md.tmp README.md

          # Commit changes locally
          git config user.name "github-actions[bot]"
          git config user.email "actions@github.com"
          git add helm/proman/Chart.yaml README.md
          git commit -m "chore(release): ${VERSION} - update Chart.appVersion and release note" || echo "no changes to commit"


      - name: Package Helm chart with appVersion
        run: |
          curl -fsSL https://get.helm.sh/helm-v3.12.0-linux-amd64.tar.gz | tar xz
          mv linux-amd64/helm /usr/local/bin/helm
          helm package helm/proman --app-version ${{ steps.set-vars.outputs.VERSION }} -d release-charts
        shell: bash

      - name: Upload packaged chart for DRY_RUN inspection
        if: ${{ env.DRY_RUN == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: release-charts
          path: release-charts

      - name: Extract release note for body
        id: release_note
        run: |
          VERSION=${{ steps.set-vars.outputs.VERSION }}
          # Extract the '## Releases' section and find the block for this version
          awk '/^## Releases/{flag=1; next} /^## / && flag{exit} flag{print}' README.md > releases-section.txt || true

          if [ -s releases-section.txt ]; then
            awk -v ver="$VERSION" '
              { lines[NR]=$0 }
              $0 ~ ("- Version:[[:space:]]*" ver) { target=NR }
              END {
                if (target) {
                  s=target-3; if (s<1) s=1
                  e=target+6; if (e>NR) e=NR
                  for(i=s;i<=e;i++) print lines[i]
                }
              }' releases-section.txt > release-note.txt || true
          fi

          if [ -s release-note.txt ]; then
            cat release-note.txt
            echo "note<<EOF" >> $GITHUB_OUTPUT
            cat release-note.txt >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "note<<EOF" >> $GITHUB_OUTPUT
            echo "Automated release for ${VERSION}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: DRY-RUN: Show intended tag & release
        if: ${{ env.DRY_RUN == 'true' }}
        run: |
          echo "DRY_RUN enabled — would create tag v${{ steps.set-vars.outputs.VERSION }} and release with extracted note"
          echo "Release note preview:"
          cat release-note.txt || true

      - name: Create annotated git tag and push
        if: ${{ env.DRY_RUN != 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ steps.set-vars.outputs.VERSION }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "actions@github.com"
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}
          git fetch --no-tags
          if git rev-parse "refs/tags/v${VERSION}" >/dev/null 2>&1; then
            echo "Tag v${VERSION} already exists"
          else
            git tag -a "v${VERSION}" -m "Release v${VERSION}"
            git push origin "v${VERSION}"
          fi

      - name: Create GitHub Release
        if: ${{ env.DRY_RUN != 'true' }}
        id: create_release
        uses: actions/create-release@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: v${{ steps.set-vars.outputs.VERSION }}
          release_name: v${{ steps.set-vars.outputs.VERSION }}
          body: ${{ steps.release_note.outputs.note }}

      - name: Upload packaged chart to release
        if: ${{ env.DRY_RUN != 'true' }}
        uses: softprops/action-gh-release@v1
        with:
          files: "release-charts/proman-*.tgz"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}